<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Java File Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    h2 { margin-top: 24px; display: inline-flex; align-items: center; gap: 10px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 24px; table-layout: auto; }
    th, td { border: 1px solid #ccc; padding: 6px 10px; text-align: left; vertical-align: top; }
    td:nth-child(2) { max-width: 600px; word-wrap: break-word; overflow-wrap: break-word; }
    input[type="checkbox"] { transform: scale(1.2); }
    input[type="text"] { width: 220px; }
    .reviewer-input { width: 140px; }

    #controls { margin-bottom: 16px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    button { margin-left: 4px; }
    select { padding: 4px; }

    .authbar { display:flex; gap:10px; align-items:center; margin:8px 0 16px; }
    .muted { color:#555; font-size:12px; }

    .summary {
      display: flex; justify-content: space-around; margin: 16px 0; padding: 12px;
      background: #f7f7f9; border: 1px solid #cfd2d6; font-weight: bold; font-size: 14px; border-radius: 8px;
    }

    .section-header { display:flex; align-items:center; justify-content:space-between; margin-top:24px; margin-bottom:8px; }
    .section-title { font-size:22px; font-weight:700; display:inline-flex; align-items:center; gap:10px; }
    .toggle-btn { cursor:pointer; border:1px solid #b9bec4; background:#fff; padding:4px 8px; border-radius:6px; font-size:12px; }

    .subfolder-header {
      background:#eef3f7; color:#1f2937; border:1px solid #cfd8e3; border-radius:8px; font-weight:600;
      padding:10px 12px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .subfolder-left, .subfolder-right { display:inline-flex; align-items:center; gap:10px; flex-wrap:wrap; }

    .status-group { display:inline-flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .status-pill { border:1px solid #cbd5e1; border-radius:999px; padding:2px 8px; font-size:12px; background:#fff; white-space:nowrap; }
    .status-ready { border-color:#22c55e; } .status-partial { border-color:#f59e0b; } .status-none { border-color:#ef4444; }
    .hidden { display:none; }
    .collapsed { display:none; }
    .disabled-note { font-size:12px; color:#666; }
  </style>
</head>
<body>
  <h1>Java File Tracker</h1>

  <div class="authbar">
    <span id="auth-status" class="muted">Sign in with your work account to view.</span>
    <button id="btn-signin">Sign in with Google</button>
    <button id="btn-signout" class="hidden">Sign out</button>
  </div>

  <div id="controls" class="hidden">
    <strong>Upload JSON:</strong> <input type="file" id="fileInput" accept=".json">
    <button id="btn-clear">Clear Local Cache</button>
    <span class="muted">(* Uploading JSON updates the shared structure in Firestore.)</span>

    <label for="exportFormat"><strong>Export as:</strong></label>
    <select id="exportFormat">
      <option value="json">JSON (structure + state + reviewers)</option>
      <option value="csv">CSV (section, subfolder, path, file, has_test, has_doc, ready)</option>
    </select>
    <button id="btn-export">Export</button>
  </div>

  <div id="summary" class="summary hidden" role="status" aria-live="polite">
    <div>üìÅ Total Files: <span id="summary-total">0</span></div>
    <div>‚úÖ With Tests: <span id="summary-tests">0</span></div>
    <div>üìù With Docs: <span id="summary-docs">0</span></div>
    <div>üîí Ready for MR: <span id="summary-approval">0</span></div>
  </div>

  <div id="summary-client" class="summary hidden" role="status" aria-live="polite">
    <div>üìÅ Client Files: <span id="client-total">0</span></div>
    <div>‚úÖ With Tests: <span id="client-tests">0</span></div>
    <div>üìù With Docs: <span id="client-docs">0</span></div>
    <div>üîí Ready for MR: <span id="client-approval">0</span></div>
  </div>

  <div id="summary-service" class="summary hidden" role="status" aria-live="polite">
    <div>üìÅ Service Files: <span id="service-total">0</span></div>
    <div>‚úÖ With Tests: <span id="service-tests">0</span></div>
    <div>üìù With Docs: <span id="service-docs">0</span></div>
    <div>üîí Ready for MR: <span id="service-approval">0</span></div>
  </div>

  <div id="content"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    // ======= CONFIGURED FOR YOU =======
    const firebaseConfig = {
      apiKey: "AIzaSyBuuPs1hcf38PnLli_MSm0K7JS-aKLO0QU",
      authDomain: "junit-files-tracker.firebaseapp.com",
      projectId: "junit-files-tracker",
      storageBucket: "junit-files-tracker.firebasestorage.app",
      messagingSenderId: "1053194892033",
      appId: "1:1053194892033:web:f33ed0a4e5aadda311e100",
      measurementId: "G-T7VJL380SX"
    };
    const TEAM_DOMAINS = ["discounttire.com"]; // Option B allowlist
    const REQUIRE_AUTH_FOR_READS = true;        // Option B
    // ===================================

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const provider = new GoogleAuthProvider();
    provider.setCustomParameters({ hd: "discounttire.com", prompt: "select_account" }); // UX hint

    // Firestore docs
    const docStructure = doc(db, "tracker", "structure");
    const docState     = doc(db, "tracker", "state");
    const docReviewers = doc(db, "tracker", "reviewers");
    const docCollapse  = doc(db, "tracker", "collapse");

    // UI helpers
    const qs  = s => document.querySelector(s);
    const qsa = s => Array.from(document.querySelectorAll(s));
    const show = (el, on=true) => (on ? el.classList.remove("hidden") : el.classList.add("hidden"));
    const setText = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = v; };

    // Runtime state
    let CAN_EDIT = false;
    let CURRENT_DATA = null;
    let CURRENT_STATE = { items:{} };
    let CURRENT_REVIEWERS = { items:{} };
    let CURRENT_COLLAPSE = { items:{} };
    const ROW_TO_FOLDER = new Map();
    const FOLDER_FILES = {};
    window._listenersAttached = false;

    function isTeamUser(user) {
      if (!user || !user.email) return false;
      const email = user.email.toLowerCase();
      return TEAM_DOMAINS.some(d => email.endsWith(`@${d.toLowerCase()}`));
    }

    // Auth UI
    const authStatus = qs("#auth-status");
    const btnSignin = qs("#btn-signin");
    const btnSignout = qs("#btn-signout");

    btnSignin.onclick = async () => { try { await signInWithPopup(auth, provider); } catch(e){ alert("Sign-in failed."); console.error(e);} };
    btnSignout.onclick = async () => { try { await signOut(auth); location.reload(); } catch(e){ console.error(e);} };

    onAuthStateChanged(auth, async (user) => {
      if (user && !isTeamUser(user)) {
        alert(`Please sign in with your work account (${TEAM_DOMAINS.join(", ")})`);
        await signOut(auth);
        return;
      }
      if (!user) {
        authStatus.textContent = "Sign in with your work account to view.";
        show(qs("#controls"), false);
        show(qs("#summary"), false);
        show(qs("#summary-client"), false);
        show(qs("#summary-service"), false);
        qs("#content").innerHTML = "";
        return;
      }

      // Team user
      CAN_EDIT = true;
      authStatus.textContent = `Signed in as ${user.email}`;
      show(btnSignin, false);
      show(btnSignout, true);
      show(qs("#controls"), true);
      show(qs("#summary"), true);
      show(qs("#summary-client"), true);
      show(qs("#summary-service"), true);

      await ensureDocs(); // create empty docs once you‚Äôre allowed

      if (!window._listenersAttached) {
        attachRealtimeListeners();
        window._listenersAttached = true;
      }
    });

    // Utils
    const b64 = s => btoa(unescape(encodeURIComponent(s)));
    const safeGet = (obj, path, fallback) => { try { return path.split('.').reduce((o,k)=>o[k], obj) ?? fallback; } catch { return fallback; } };

    function toggleEditability(can) {
      qsa("input[type='checkbox'], .reviewer-input, .rev-save-btn").forEach(el => {
        if (can) el.removeAttribute("disabled"); else el.setAttribute("disabled","true");
      });
      qsa(".edit-note").forEach(el => el.classList.toggle("hidden", can));
    }
    function getRowKey(path, file){ return `${path}::${file}`; }

    // Stats + phrases
    function computeStatsForFiles(files) {
      const items = safeGet(CURRENT_STATE, "items", {});
      const out = { total: 0, tests: 0, docs: 0, ready: 0 };
      for (const f of files) {
        out.total++;
        const k = b64(getRowKey(f.path, f.file));
        const s = items[k] || {};
        if (s.has_test) out.tests++;
        if (s.has_doc)  out.docs++;
        if (s.ready)    out.ready++;
      }
      return out;
    }
    function phraseFor(count, total, type, testsAll) {
      if (total === 0) return { text: "", cls: "" };
      const all = count === total, none = count === 0;
      if (type === "tests")  return all ? {text:"Test Files are ready", cls:"status-ready"} :
                                   none ? {text:"Start creating test files", cls:"status-none"} :
                                          {text:"Test Files are in progress", cls:"status-partial"};
      if (type === "docs")   return all ? {text:"Docs Ready", cls:"status-ready"} :
                                   none ? {text:"Start working on creating Docs", cls:"status-none"} :
                                          {text:"Docs are in progress", cls:"status-partial"};
      if (type === "ready") {
        if (all)  return { text:"Ready for MR", cls:"status-ready" };
        if (none) return testsAll ? { text:"Ask someone to review", cls:"status-none"} : { text:"", cls:"hidden" };
        return { text:"Still being reviewed", cls:"status-partial" };
      }
      return { text:"", cls:"" };
    }
    function updateSubfolderStatus(folderId) {
      const files = FOLDER_FILES[folderId] || [];
      const s = computeStatsForFiles(files);
      const testsAll = s.tests === s.total;
      const tests = phraseFor(s.tests, s.total, "tests", testsAll);
      const docs  = phraseFor(s.docs,  s.total, "docs",  testsAll);
      const ready = phraseFor(s.ready, s.total, "ready", testsAll);

      const root = document.getElementById(`${folderId}-statuses`);
      if (!root) return;
      const t = root.querySelector(".tests");
      const d = root.querySelector(".docs");
      const r = root.querySelector(".ready");
      if (t) { t.textContent = tests.text; t.className = `status-pill tests ${tests.cls}`; }
      if (d) { d.textContent = docs.text;  d.className = `status-pill docs ${docs.cls}`; }
      if (r) {
        r.textContent = ready.text;
        r.className = `status-pill ready ${ready.cls}`;
        if (!ready.text) r.classList.add("hidden");
      }
    }
    function refreshAllSubfolderStatuses(){ Object.keys(FOLDER_FILES).forEach(updateSubfolderStatus); }

    function computeSectionStats(data, sectionName) {
      const out = { total: 0, tests: 0, docs: 0, approval: 0 };
      if (!data || !data[sectionName]) return out;
      const items = safeGet(CURRENT_STATE, "items", {});
      for (const subfolder in data[sectionName]) {
        for (const file of data[sectionName][subfolder]) {
          out.total++;
          const k = b64(getRowKey(file.path, file.file));
          const s = items[k] || {};
          if (s.has_test) out.tests++;
          if (s.has_doc)  out.docs++;
          if (s.ready)    out.approval++;
        }
      }
      return out;
    }
    function setBar(prefix, stats) {
      setText(`${prefix}-total`, stats.total);
      setText(`${prefix}-tests`, stats.tests);
      setText(`${prefix}-docs`, stats.docs);
      setText(`${prefix}-approval`, stats.approval);
    }
    function renderSummary(data) {
      if (!data) {
        const zero = { total: 0, tests: 0, docs: 0, approval: 0 };
        setBar("summary", zero); setBar("client", zero); setBar("service", zero);
        return;
      }
      const client = computeSectionStats(data, "client");
      const service = computeSectionStats(data, "service");
      setBar("client", client);
      setBar("service", service);
      setBar("summary", {
        total: client.total + service.total,
        tests: client.tests + service.tests,
        docs: client.docs + service.docs,
        approval: client.approval + service.approval
      });
    }

    // DOM builders
    function createTopSection(sectionName, prettyTitle, dataForSection) {
      const collapse = safeGet(CURRENT_COLLAPSE, "items", {});
      const sectionId = `${sectionName}-section`;

      const wrapper = document.createElement('section');
      wrapper.id = sectionId + "-wrapper";

      const header = document.createElement('div');
      header.className = "section-header";
      header.innerHTML = `
        <div class="section-title">
          <span>${prettyTitle}</span>
          <button id="${sectionId}-toggle" class="toggle-btn" aria-expanded="${!collapse[sectionId]}" aria-controls="${sectionId}-content">${collapse[sectionId] ? "Expand ‚ñ∏" : "Collapse ‚ñæ"}</button>
        </div>
      `;

      const content = document.createElement('div');
      content.id = `${sectionId}-content`;
      content.setAttribute("role", "region");
      content.setAttribute("aria-label", `${prettyTitle} content`);
      content.appendChild(createTableSection(dataForSection));
      if (collapse[sectionId]) content.classList.add("collapsed");

      header.querySelector('button').addEventListener('click', async () => {
        const nowCollapsed = !content.classList.contains('collapsed');
        if (nowCollapsed) {
          content.classList.add('collapsed'); header.querySelector('button').textContent = "Expand ‚ñ∏";
          header.querySelector('button').setAttribute("aria-expanded","false");
        } else {
          content.classList.remove('collapsed'); header.querySelector('button').textContent = "Collapse ‚ñæ";
          header.querySelector('button').setAttribute("aria-expanded","true");
        }
        try { await updateDoc(docCollapse, { [`items.${sectionId}`]: nowCollapsed }); } catch(e){ console.error(e); }
      });

      wrapper.appendChild(header);
      wrapper.appendChild(content);
      return wrapper;
    }

    function createTableSection(sectionData) {
      const collapse = safeGet(CURRENT_COLLAPSE, "items", {});
      const reviewers = safeGet(CURRENT_REVIEWERS, "items", {});
      const items = safeGet(CURRENT_STATE, "items", {});
      const section = document.createElement('div');

      for (const [subfolder, files] of Object.entries(sectionData)) {
        const folderId = `folder_${subfolder.replace(/[^\w]/g, "_")}`;
        FOLDER_FILES[folderId] = files;

        const wrapper = document.createElement('div');
        const header = document.createElement('div');
        header.className = "subfolder-header";
        const reviewerValue = reviewers[folderId] || "";

        header.innerHTML = `
          <div class="subfolder-left">
            <span>${subfolder} ‚Äî Reviewer:</span>
            <input type="text" id="rev_input_${folderId}" class="reviewer-input" placeholder="Name" aria-label="Reviewer for ${subfolder}" value="${reviewerValue}">
            <button class="toggle-btn rev-save-btn" id="${folderId}-saverev" title="Save reviewer">Save</button>
            <span class="disabled-note edit-note ${CAN_EDIT ? 'hidden' : ''}">Sign in to edit</span>
          </div>
          <div class="subfolder-right">
            <span class="status-group" id="${folderId}-statuses">
              <span class="status-pill tests"></span>
              <span class="status-pill docs"></span>
              <span class="status-pill ready"></span>
            </span>
            <button id="${folderId}-toggle" class="toggle-btn" aria-expanded="${!collapse[folderId]}" aria-controls="${folderId}-content">${collapse[folderId] ? "Expand ‚ñ∏" : "Collapse ‚ñæ"}</button>
          </div>
        `;

        const content = document.createElement('div');
        content.id = `${folderId}-content`;
        if (collapse[folderId]) content.classList.add('collapsed');

        const rowsHtml = files.map((f) => {
          const key = getRowKey(f.path, f.file);
          const k64 = b64(key);
          ROW_TO_FOLDER.set(key, folderId);
          const fileState = items[k64] || {};
          return `
            <tr data-key="${key}" data-folder="${folderId}">
              <td>${f.file}</td>
              <td>${f.path}</td>
              <td><input type="checkbox" class="has_test" ${fileState.has_test ? "checked" : ""} ${CAN_EDIT ? "" : "disabled"}></td>
              <td><input type="checkbox" class="has_doc"  ${fileState.has_doc  ? "checked" : ""} ${CAN_EDIT ? "" : "disabled"}></td>
              <td><input type="checkbox" class="ready"    ${fileState.ready    ? "checked" : ""} ${CAN_EDIT ? "" : "disabled"}></td>
            </tr>
          `;
        }).join("");

        content.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>File</th>
                <th>Path</th>
                <th>Has Test</th>
                <th>Has Doc</th>
                <th>Ready for MR</th>
              </tr>
            </thead>
            <tbody id="tbody_${folderId}">
              ${rowsHtml}
            </tbody>
          </table>
        `;

        header.querySelector(`#${folderId}-toggle`).addEventListener('click', async () => {
          const nowCollapsed = !content.classList.contains('collapsed');
          if (nowCollapsed) {
            content.classList.add('collapsed');
            header.querySelector(`#${folderId}-toggle`).textContent = "Expand ‚ñ∏";
            header.querySelector(`#${folderId}-toggle`).setAttribute("aria-expanded","false");
          } else {
            content.classList.remove('collapsed');
            header.querySelector(`#${folderId}-toggle`).textContent = "Collapse ‚ñæ";
            header.querySelector(`#${folderId}-toggle`).setAttribute("aria-expanded","true");
          }
          try { await updateDoc(docCollapse, { [`items.${folderId}`]: nowCollapsed }); } catch(e){ console.error(e); }
        });

        header.querySelector(`#${folderId}-saverev`).addEventListener('click', async () => {
          if (!CAN_EDIT) return alert("Sign in to edit.");
          const name = (document.getElementById(`rev_input_${folderId}`).value || "").trim();
          try { await setDoc(docReviewers, { items: { [folderId]: name } }, { merge: true }); }
          catch(e){ alert("No permission to save reviewer."); console.error(e); }
        });

        wrapper.appendChild(header);
        wrapper.appendChild(content);
        section.appendChild(wrapper);

        updateSubfolderStatus(folderId);
      }

      toggleEditability(CAN_EDIT);
      return section;
    }

    function attachListeners() {
      qsa("tbody tr").forEach((row) => {
        const key = row.dataset.key;
        const k64 = b64(key);
        row.querySelectorAll("input[type='checkbox']").forEach((checkbox) => {
          checkbox.addEventListener("change", async () => {
            if (!CAN_EDIT) { checkbox.checked = !checkbox.checked; return alert("Sign in with your work account to edit."); }
            const payload = {
              has_test: row.querySelector(".has_test").checked,
              has_doc:  row.querySelector(".has_doc").checked,
              ready:    row.querySelector(".ready").checked
            };
            try {
              await setDoc(docState, { items: { [k64]: payload } }, { merge: true });
            } catch (e) {
              alert("You don't have permission to save changes."); console.error(e);
            }
          });
        });
      });
    }

    function renderFromData(data) {
      const container = document.getElementById('content');
      container.innerHTML = "";
      renderSummary(data);
      if (data && data.client) container.appendChild(createTopSection("client", "Client Files", data.client));
      if (data && data.service) container.appendChild(createTopSection("service", "Service Files", data.service));
      attachListeners();
      refreshAllSubfolderStatuses();
    }

    // Real-time listeners (attach only after team sign-in)
    function attachRealtimeListeners() {
      onSnapshot(docStructure, (snap) => {
        CURRENT_DATA = snap.exists() ? snap.data() : null;
        renderFromData(CURRENT_DATA);
      }, (e) => console.error(e));

      onSnapshot(docState, (snap) => {
        CURRENT_STATE = snap.exists() ? snap.data() : { items:{} };
        renderSummary(CURRENT_DATA);
        refreshAllSubfolderStatuses();
      }, (e) => console.error(e));

      onSnapshot(docReviewers, (snap) => {
        CURRENT_REVIEWERS = snap.exists() ? snap.data() : { items:{} };
        Object.entries(CURRENT_REVIEWERS.items || {}).forEach(([folderId, name]) => {
          const el = document.getElementById(`rev_input_${folderId}`);
          if (el) el.value = name || "";
        });
      }, (e) => console.error(e));

      onSnapshot(docCollapse, (snap) => {
        CURRENT_COLLAPSE = snap.exists() ? snap.data() : { items:{} };
      }, (e) => console.error(e));
    }

    // Create empty docs after sign-in (allowed by Option B rules)
    async function ensureDocs() {
      try {
        if (!(await getDoc(docStructure)).exists()) await setDoc(docStructure, {});
        if (!(await getDoc(docState)).exists())     await setDoc(docState,     { items:{} });
        if (!(await getDoc(docReviewers)).exists()) await setDoc(docReviewers, { items:{} });
        if (!(await getDoc(docCollapse)).exists())  await setDoc(docCollapse,  { items:{} });
      } catch (e) { console.warn("ensureDocs failed (permissions?):", e); }
    }

    // Upload / Export
    document.getElementById("btn-export").onclick = () => exportJSON();
    document.getElementById("exportFormat").addEventListener("change", (e) => {
      document.getElementById("btn-export").onclick = e.target.value === "csv" ? exportCSV : exportJSON;
    });

    document.getElementById('fileInput').addEventListener('change', function(evt) {
      const file = evt.target.files[0];
      const reader = new FileReader();
      reader.onload = async (e) => {
        if (!CAN_EDIT) return alert("Sign in with your work account to upload.");
        const incoming = JSON.parse(e.target.result);
        try {
          if (incoming && incoming.data && (incoming.state || incoming.reviewers)) {
            if (incoming.data)       await setDoc(docStructure, incoming.data, { merge: false });
            if (incoming.state)      await setDoc(docState, incoming.state, { merge: false });
            if (incoming.reviewers)  await setDoc(docReviewers, incoming.reviewers, { merge: false });
          } else {
            await setDoc(docStructure, incoming, { merge: false });
          }
          alert("Upload saved to Firestore.");
        } catch (err) {
          alert("Upload failed. Do you have permission?"); console.error(err);
        }
      };
      reader.readAsText(file);
      evt.target.value = "";
    });

    function exportJSON() {
      const payload = {
        meta: { exported_at: new Date().toISOString(), version: "2.0", notes: "Includes structure, state, reviewers." },
        data: CURRENT_DATA || null,
        state: CURRENT_STATE || { items:{} },
        reviewers: CURRENT_REVIEWERS || { items:{} }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = "java_file_tracker_export.json";
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    async function exportCSV() {
      const data = CURRENT_DATA;
      const items = safeGet(CURRENT_STATE, "items", {});
      if (!data) return alert("No tracker data found to export.");
      const headers = ["section","subfolder","path","file","has_test","has_doc","ready"];
      const rows = [headers];

      for (const section of ["client","service"]) {
        if (!data[section]) continue;
        for (const subfolder in data[section]) {
          for (const fileObj of data[section][subfolder]) {
            const k64 = b64(getRowKey(fileObj.path, fileObj.file));
            const s = items[k64] || {};
            rows.push([
              section, subfolder, fileObj.path, fileObj.file,
              s.has_test ? "Yes" : "No",
              s.has_doc  ? "Yes" : "No",
              s.ready    ? "Yes" : "No"
            ]);
          }
        }
      }
      const csvContent = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
      const csvWithBom = "\uFEFF" + csvContent;
      const blob = new Blob([csvWithBom], { type:"text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = "java_file_tracker_export.csv";
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    document.getElementById("btn-clear").onclick = () => { localStorage.clear(); alert("Local cache cleared."); };
  </script>
</body>
</html>
