<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Java File Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    h2 { margin-top: 24px; display: inline-flex; align-items: center; gap: 10px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 24px; table-layout: auto; }
    th, td { border: 1px solid #ccc; padding: 6px 10px; text-align: left; vertical-align: top; }
    td:nth-child(2) { max-width: 600px; word-wrap: break-word; overflow-wrap: break-word; }
    input[type="checkbox"] { transform: scale(1.2); }
    input[type="text"] { width: 220px; }
    .reviewer-input { width: 140px; }

    #controls { margin-bottom: 16px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    button { margin-left: 4px; }
    select { padding: 4px; }

    .authbar { display:flex; gap:10px; align-items:center; margin:8px 0 16px; }
    .muted { color:#555; font-size:12px; }

    /* Summary bars */
    .summary {
      display: flex; justify-content: space-around; margin: 16px 0; padding: 12px;
      background: #f7f7f9; border: 1px solid #cfd2d6; font-weight: bold; font-size: 14px; border-radius: 8px;
    }

    /* Section headers */
    .section-header { display:flex; align-items:center; justify-content:space-between; margin-top:24px; margin-bottom:8px; }
    .section-title { font-size:22px; font-weight:700; display:inline-flex; align-items:center; gap:10px; }
    .toggle-btn { cursor:pointer; border:1px solid #b9bec4; background:#fff; padding:4px 8px; border-radius:6px; font-size:12px; }

    /* Subfolder title bar (neutral, high-contrast) */
    .subfolder-header {
      background:#eef3f7; color:#1f2937; border:1px solid #cfd8e3; border-radius:8px; font-weight:600;
      padding:10px 12px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .subfolder-left, .subfolder-right { display:inline-flex; align-items:center; gap:10px; flex-wrap:wrap; }

    /* Status phrases */
    .status-group { display:inline-flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .status-pill { border:1px solid #cbd5e1; border-radius:999px; padding:2px 8px; font-size:12px; background:#fff; white-space:nowrap; }
    .status-ready { border-color:#22c55e; } .status-partial { border-color:#f59e0b; } .status-none { border-color:#ef4444; }
    .hidden { display:none; }

    .collapsed { display:none; }
    .disabled-note { font-size:12px; color:#666; }
  </style>
</head>
<body>
  <h1>Java File Tracker</h1>

  <!-- Auth UI -->
  <div class="authbar">
    <span id="auth-status" class="muted">Not signed in (view-only)</span>
    <button id="btn-signin">Sign in with Google</button>
    <button id="btn-signout" class="hidden">Sign out</button>
  </div>

  <div id="controls">
    <strong>Upload JSON:</strong> <input type="file" id="fileInput" accept=".json">
    <button id="btn-clear">Clear Local Cache</button>
    <span class="muted">(* Uploading JSON updates the shared structure in Firestore.)</span>

    <label for="exportFormat"><strong>Export as:</strong></label>
    <select id="exportFormat">
      <option value="json">JSON (structure + state + reviewers)</option>
      <option value="csv">CSV (section, subfolder, path, file, has_test, has_doc, ready)</option>
    </select>
    <button id="btn-export">Export</button>
  </div>

  <!-- Overall summary -->
  <div id="summary" class="summary" role="status" aria-live="polite">
    <div>üìÅ Total Files: <span id="summary-total">0</span></div>
    <div>‚úÖ With Tests: <span id="summary-tests">0</span></div>
    <div>üìù With Docs: <span id="summary-docs">0</span></div>
    <div>üîí Ready for MR: <span id="summary-approval">0</span></div>
  </div>

  <!-- Client summary -->
  <div id="summary-client" class="summary" role="status" aria-live="polite">
    <div>üìÅ Client Files: <span id="client-total">0</span></div>
    <div>‚úÖ With Tests: <span id="client-tests">0</span></div>
    <div>üìù With Docs: <span id="client-docs">0</span></div>
    <div>üîí Ready for MR: <span id="client-approval">0</span></div>
  </div>

  <!-- Service summary -->
  <div id="summary-service" class="summary" role="status" aria-live="polite">
    <div>üìÅ Service Files: <span id="service-total">0</span></div>
    <div>‚úÖ With Tests: <span id="service-tests">0</span></div>
    <div>üìù With Docs: <span id="service-docs">0</span></div>
    <div>üîí Ready for MR: <span id="service-approval">0</span></div>
  </div>

  <div id="content"></div>

  <!-- Firebase (v10 modular CDN) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    // ======= 1) CONFIGURE THIS =======
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_PROJECT.appspot.com",
      messagingSenderId: "YOUR_SENDER_ID",
      appId: "YOUR_APP_ID"
    };
    // ==================================

    // Firebase init
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    // Collection/docs layout
    // /tracker/structure -> { client: {...}, service:{...} }
    // /tracker/state     -> { items: { <b64key>: {has_test,has_doc,ready} } }
    // /tracker/reviewers -> { items: { <folderId>: "Name" } }
    // /tracker/collapse  -> { items: { <sectionId|folderId>: true } }
    const docStructure = doc(db, "tracker", "structure");
    const docState     = doc(db, "tracker", "state");
    const docReviewers = doc(db, "tracker", "reviewers");
    const docCollapse  = doc(db, "tracker", "collapse");

    // Local runtime
    let CURRENT_DATA = null;       // structure
    let CAN_EDIT = false;          // toggled by auth state
    const ROW_TO_FOLDER = new Map();
    const FOLDER_FILES = {};

    // Helpers
    const b64 = s => btoa(unescape(encodeURIComponent(s)));
    const unb64 = s => decodeURIComponent(escape(atob(s)));

    const safeGet = (obj, path, fallback) => {
      try { return path.split('.').reduce((o,k)=>o[k], obj) ?? fallback; } catch { return fallback; }
    };

    // UI elements
    const qs  = sel => document.querySelector(sel);
    const qsa = sel => Array.from(document.querySelectorAll(sel));
    const setText = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = v; };

    // Auth UI
    const authStatus = qs("#auth-status");
    const btnSignin = qs("#btn-signin");
    const btnSignout = qs("#btn-signout");

    btnSignin.addEventListener("click", async () => { await signInWithPopup(auth, provider); });
    btnSignout.addEventListener("click", async () => { await signOut(auth); });

    onAuthStateChanged(auth, async (user) => {
      CAN_EDIT = !!user;
      if (user) {
        authStatus.textContent = `Signed in as ${user.email}`;
        btnSignin.classList.add("hidden");
        btnSignout.classList.remove("hidden");
      } else {
        authStatus.textContent = "Not signed in (view-only)";
        btnSignin.classList.remove("hidden");
        btnSignout.classList.add("hidden");
      }
      // toggle inputs
      toggleEditability(CAN_EDIT);
    });

    function toggleEditability(can) {
      qsa("input[type='checkbox'], .reviewer-input, .rev-save-btn").forEach(el => {
        if (can) el.removeAttribute("disabled"); else el.setAttribute("disabled","true");
      });
      qsa(".edit-note").forEach(el => el.classList.toggle("hidden", can));
    }

    // ===== Render / Stats (same logic as your latest version) =====
    function getRowKey(path, file){ return `${path}::${file}`; }

    function computeStatsForFiles(files) {
      const items = safeGet(CURRENT_STATE, "items", {});
      const out = { total: 0, tests: 0, docs: 0, ready: 0 };
      for (const f of files) {
        out.total++;
        const k = b64(getRowKey(f.path, f.file));
        const s = items[k] || {};
        if (s.has_test) out.tests++;
        if (s.has_doc)  out.docs++;
        if (s.ready)    out.ready++;
      }
      return out;
    }

    function phraseFor(count, total, type, testsAll) {
      if (total === 0) return { text: "", cls: "" };
      const all = count === total, none = count === 0;
      if (type === "tests")  return all ? {text:"Test Files are ready", cls:"status-ready"} :
                                   none ? {text:"Start creating test files", cls:"status-none"} :
                                          {text:"Test Files are in progress", cls:"status-partial"};
      if (type === "docs")   return all ? {text:"Docs Ready", cls:"status-ready"} :
                                   none ? {text:"Start working on creating Docs", cls:"status-none"} :
                                          {text:"Docs are in progress", cls:"status-partial"};
      if (type === "ready") {
        if (all)  return { text:"Ready for MR", cls:"status-ready" };
        if (none) return testsAll ? { text:"Ask someone to review", cls:"status-none"} : { text:"", cls:"hidden" };
        return { text:"Still being reviewed", cls:"status-partial" };
      }
      return { text:"", cls:"" };
    }

    function updateSubfolderStatus(folderId) {
      const files = FOLDER_FILES[folderId] || [];
      const s = computeStatsForFiles(files);
      const testsAll = s.tests === s.total;

      const tests = phraseFor(s.tests, s.total, "tests", testsAll);
      const docs  = phraseFor(s.docs,  s.total, "docs",  testsAll);
      const ready = phraseFor(s.ready, s.total, "ready", testsAll);

      const root = document.getElementById(`${folderId}-statuses`);
      if (!root) return;
      const t = root.querySelector(".tests");
      const d = root.querySelector(".docs");
      const r = root.querySelector(".ready");
      if (t) { t.textContent = tests.text; t.className = `status-pill tests ${tests.cls}`; }
      if (d) { d.textContent = docs.text;  d.className = `status-pill docs ${docs.cls}`; }
      if (r) {
        r.textContent = ready.text;
        r.className = `status-pill ready ${ready.cls}`;
        if (!ready.text) r.classList.add("hidden");
      }
    }

    function refreshAllSubfolderStatuses() {
      Object.keys(FOLDER_FILES).forEach(updateSubfolderStatus);
    }

    function computeSectionStats(data, sectionName) {
      const out = { total: 0, tests: 0, docs: 0, approval: 0 };
      if (!data || !data[sectionName]) return out;
      const items = safeGet(CURRENT_STATE, "items", {});
      for (const subfolder in data[sectionName]) {
        for (const file of data[sectionName][subfolder]) {
          out.total++;
          const k = b64(getRowKey(file.path, file.file));
          const s = items[k] || {};
          if (s.has_test) out.tests++;
          if (s.has_doc)  out.docs++;
          if (s.ready)    out.approval++;
        }
      }
      return out;
    }

    function setBar(prefix, stats) {
      setText(`${prefix}-total`, stats.total);
      setText(`${prefix}-tests`, stats.tests);
      setText(`${prefix}-docs`, stats.docs);
      setText(`${prefix}-approval`, stats.approval);
    }

    function renderSummary(data) {
      if (!data) {
        const zero = { total: 0, tests: 0, docs: 0, approval: 0 };
        setBar("summary", zero); setBar("client", zero); setBar("service", zero);
        return;
      }
      const client = computeSectionStats(data, "client");
      const service = computeSectionStats(data, "service");
      setBar("client", client);
      setBar("service", service);
      setBar("summary", {
        total: client.total + service.total,
        tests: client.tests + service.tests,
        docs: client.docs + service.docs,
        approval: client.approval + service.approval
      });
    }

    // ===== DOM Builders =====
    function createTopSection(sectionName, prettyTitle, dataForSection) {
      const collapse = safeGet(CURRENT_COLLAPSE, "items", {});
      const sectionId = `${sectionName}-section`;

      const wrapper = document.createElement('section');
      wrapper.id = sectionId + "-wrapper";

      const header = document.createElement('div');
      header.className = "section-header";
      header.innerHTML = `
        <div class="section-title">
          <span>${prettyTitle}</span>
          <button id="${sectionId}-toggle" class="toggle-btn" aria-expanded="true" aria-controls="${sectionId}-content">Collapse ‚ñæ</button>
        </div>
      `;

      const content = document.createElement('div');
      content.id = `${sectionId}-content`;
      content.setAttribute("role", "region");
      content.setAttribute("aria-label", `${prettyTitle} content`);
      content.appendChild(createTableSection(dataForSection));

      if (collapse[sectionId]) content.classList.add("collapsed");

      header.querySelector('button').addEventListener('click', async () => {
        const nowCollapsed = !content.classList.contains('collapsed');
        if (nowCollapsed) {
          content.classList.add('collapsed'); header.querySelector('button').textContent = "Expand ‚ñ∏";
          header.querySelector('button').setAttribute("aria-expanded","false");
        } else {
          content.classList.remove('collapsed'); header.querySelector('button').textContent = "Collapse ‚ñæ";
          header.querySelector('button').setAttribute("aria-expanded","true");
        }
        await updateDoc(docCollapse, { [`items.${sectionId}`]: nowCollapsed });
      });

      wrapper.appendChild(header);
      wrapper.appendChild(content);
      return wrapper;
    }

    function createTableSection(sectionData) {
      const collapse = safeGet(CURRENT_COLLAPSE, "items", {});
      const reviewers = safeGet(CURRENT_REVIEWERS, "items", {});
      const items = safeGet(CURRENT_STATE, "items", {});
      const section = document.createElement('div');

      for (const [subfolder, files] of Object.entries(sectionData)) {
        const folderId = `folder_${subfolder.replace(/[^\w]/g, "_")}`;
        FOLDER_FILES[folderId] = files;

        const wrapper = document.createElement('div');

        const header = document.createElement('div');
        header.className = "subfolder-header";
        const reviewerValue = reviewers[folderId] || "";

        header.innerHTML = `
          <div class="subfolder-left">
            <span>${subfolder} ‚Äî Reviewer:</span>
            <input type="text" id="rev_input_${folderId}" class="reviewer-input" placeholder="Name" aria-label="Reviewer for ${subfolder}" value="${reviewerValue}">
            <button class="toggle-btn rev-save-btn" id="${folderId}-saverev" title="Save reviewer">Save</button>
            <span class="disabled-note edit-note ${CAN_EDIT ? 'hidden' : ''}">Sign in to edit</span>
          </div>
          <div class="subfolder-right">
            <span class="status-group" id="${folderId}-statuses">
              <span class="status-pill tests"></span>
              <span class="status-pill docs"></span>
              <span class="status-pill ready"></span>
            </span>
            <button id="${folderId}-toggle" class="toggle-btn" aria-expanded="${!collapse[folderId]}" aria-controls="${folderId}-content">${collapse[folderId] ? "Expand ‚ñ∏" : "Collapse ‚ñæ"}</button>
          </div>
        `;

        const content = document.createElement('div');
        content.id = `${folderId}-content`;
        if (collapse[folderId]) content.classList.add('collapsed');

        const rowsHtml = files.map((f) => {
          const key = getRowKey(f.path, f.file);
          const k64 = b64(key);
          ROW_TO_FOLDER.set(key, folderId);
          const fileState = items[k64] || {};
          return `
            <tr data-key="${key}" data-folder="${folderId}">
              <td>${f.file}</td>
              <td>${f.path}</td>
              <td><input type="checkbox" class="has_test" ${fileState.has_test ? "checked" : ""} ${CAN_EDIT ? "" : "disabled"}></td>
              <td><input type="checkbox" class="has_doc"  ${fileState.has_doc  ? "checked" : ""} ${CAN_EDIT ? "" : "disabled"}></td>
              <td><input type="checkbox" class="ready"    ${fileState.ready    ? "checked" : ""} ${CAN_EDIT ? "" : "disabled"}></td>
            </tr>
          `;
        }).join("");

        content.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>File</th>
                <th>Path</th>
                <th>Has Test</th>
                <th>Has Doc</th>
                <th>Ready for MR</th>
              </tr>
            </thead>
            <tbody id="tbody_${folderId}">
              ${rowsHtml}
            </tbody>
          </table>
        `;

        // Toggle collapse
        header.querySelector(`#${folderId}-toggle`).addEventListener('click', async () => {
          const nowCollapsed = !content.classList.contains('collapsed');
          if (nowCollapsed) {
            content.classList.add('collapsed');
            header.querySelector(`#${folderId}-toggle`).textContent = "Expand ‚ñ∏";
            header.querySelector(`#${folderId}-toggle`).setAttribute("aria-expanded","false");
          } else {
            content.classList.remove('collapsed');
            header.querySelector(`#${folderId}-toggle`).textContent = "Collapse ‚ñæ";
            header.querySelector(`#${folderId}-toggle`).setAttribute("aria-expanded","true");
          }
          await updateDoc(docCollapse, { [`items.${folderId}`]: nowCollapsed });
        });

        // Save reviewer
        header.querySelector(`#${folderId}-saverev`).addEventListener('click', async () => {
          if (!CAN_EDIT) return alert("Sign in to edit.");
          const name = (document.getElementById(`rev_input_${folderId}`).value || "").trim();
          await setDoc(docReviewers, { items: { [folderId]: name } }, { merge: true });
        });

        wrapper.appendChild(header);
        wrapper.appendChild(content);
        section.appendChild(wrapper);

        // Initial phrases
        updateSubfolderStatus(folderId);
      }

      // after initial render, ensure inputs reflect editability
      toggleEditability(CAN_EDIT);
      return section;
    }

    function attachListeners() {
      qsa("tbody tr").forEach((row) => {
        const key = row.dataset.key;
        const k64 = b64(key);
        row.querySelectorAll("input[type='checkbox']").forEach((checkbox) => {
          checkbox.addEventListener("change", async () => {
            if (!CAN_EDIT) { checkbox.checked = !checkbox.checked; return alert("Sign in to edit."); }
            const payload = {
              has_test: row.querySelector(".has_test").checked,
              has_doc:  row.querySelector(".has_doc").checked,
              ready:    row.querySelector(".ready").checked
            };
            await setDoc(docState, { items: { [k64]: payload } }, { merge: true });
          });
        });
      });
    }

    function renderFromData(data) {
      const container = document.getElementById('content');
      container.innerHTML = "";
      renderSummary(data);
      if (data && data.client) container.appendChild(createTopSection("client", "Client Files", data.client));
      if (data && data.service) container.appendChild(createTopSection("service", "Service Files", data.service));
      attachListeners();
      refreshAllSubfolderStatuses();
    }

    // ===== Firestore reactive sync =====
    let CURRENT_STATE = { items:{} };
    let CURRENT_REVIEWERS = { items:{} };
    let CURRENT_COLLAPSE = { items:{} };

    // Live listeners: keep UI in sync for everyone
    onSnapshot(docStructure, (snap) => {
      CURRENT_DATA = snap.exists() ? snap.data() : null;
      renderFromData(CURRENT_DATA);
    });

    onSnapshot(docState, (snap) => {
      CURRENT_STATE = snap.exists() ? snap.data() : { items:{} };
      renderSummary(CURRENT_DATA);
      refreshAllSubfolderStatuses();
    });

    onSnapshot(docReviewers, (snap) => {
      CURRENT_REVIEWERS = snap.exists() ? snap.data() : { items:{} };
      // update inputs without full re-render
      Object.entries(CURRENT_REVIEWERS.items || {}).forEach(([folderId, name]) => {
        const el = document.getElementById(`rev_input_${folderId}`);
        if (el) el.value = name || "";
      });
    });

    onSnapshot(docCollapse, (snap) => {
      CURRENT_COLLAPSE = snap.exists() ? snap.data() : { items:{} };
      // no immediate DOM patch; respected on next render/toggle
    });

    // ===== Upload / Export =====
    document.getElementById('fileInput').addEventListener('change', function(evt) {
      const file = evt.target.files[0];
      const reader = new FileReader();
      reader.onload = async (e) => {
        const incoming = JSON.parse(e.target.result);

        // Accept either export bundle or plain structure
        if (incoming && incoming.data && (incoming.state || incoming.reviewers)) {
          // Export bundle
          if (incoming.data) await setDoc(docStructure, incoming.data, { merge: false });
          if (incoming.state) await setDoc(docState, incoming.state, { merge: false });
          if (incoming.reviewers) await setDoc(docReviewers, incoming.reviewers, { merge: false });
        } else {
          // Plain structure only
          await setDoc(docStructure, incoming, { merge: false });
        }
        alert("Upload saved to Firestore.");
      };
      reader.readAsText(file);
      // clear file input to allow re-upload same file later
      evt.target.value = "";
    });

    document.getElementById("btn-export").addEventListener("click", async () => {
      const payload = {
        meta: {
          exported_at: new Date().toISOString(),
          version: "2.0",
          notes: "Includes structure, state, reviewers."
        },
        data: CURRENT_DATA || null,
        state: CURRENT_STATE || { items:{} },
        reviewers: CURRENT_REVIEWERS || { items:{} }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "java_file_tracker_export.json";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // CSV export (reads from live state)
    document.getElementById("btn-export").insertAdjacentHTML("afterend", "");
    async function exportCSV() {
      const data = CURRENT_DATA;
      const items = safeGet(CURRENT_STATE, "items", {});
      if (!data) return alert("No tracker data found to export.");

      const headers = ["section","subfolder","path","file","has_test","has_doc","ready"];
      const rows = [headers];

      for (const section of ["client","service"]) {
        if (!data[section]) continue;
        for (const subfolder in data[section]) {
          for (const fileObj of data[section][subfolder]) {
            const k64 = b64(getRowKey(fileObj.path, fileObj.file));
            const s = items[k64] || {};
            rows.push([
              section, subfolder, fileObj.path, fileObj.file,
              s.has_test ? "Yes" : "No",
              s.has_doc  ? "Yes" : "No",
              s.ready    ? "Yes" : "No"
            ]);
          }
        }
      }
      const csvContent = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
      const csvWithBom = "\uFEFF" + csvContent;
      const blob = new Blob([csvWithBom], { type:"text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "java_file_tracker_export.csv";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.getElementById("exportFormat").addEventListener("change", (e) => {
      qs("#btn-export").onclick = e.target.value === "csv" ? exportCSV : null;
    });
    // default: json export
    qs("#btn-export").onclick = null;

    // Clear local cache (does not touch Firestore)
    document.getElementById("btn-clear").addEventListener("click", () => {
      localStorage.clear();
      alert("Local cache cleared. (Shared Firestore data untouched.)");
    });

    // Initial bootstrap: ensure docs exist (so onSnapshot works cleanly)
    async function ensureDocs() {
      if (!(await getDoc(docStructure)).exists()) await setDoc(docStructure, {});
      if (!(await getDoc(docState)).exists())     await setDoc(docState,     { items:{} });
      if (!(await getDoc(docReviewers)).exists()) await setDoc(docReviewers, { items:{} });
      if (!(await getDoc(docCollapse)).exists())  await setDoc(docCollapse,  { items:{} });
    }
    await ensureDocs();
  </script>
</body>
</html>
